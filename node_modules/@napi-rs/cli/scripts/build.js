"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BuildCommand = void 0;
const tslib_1 = require("tslib");
const child_process_1 = require("child_process");
const path_1 = require("path");
const chalk_1 = tslib_1.__importDefault(require("chalk"));
const clipanion_1 = require("clipanion");
const toml_1 = tslib_1.__importDefault(require("toml"));
const consts_1 = require("./consts");
const debug_1 = require("./debug");
const parse_triple_1 = require("./parse-triple");
const utils_1 = require("./utils");
const debug = debug_1.debugFactory('build');
class BuildCommand extends clipanion_1.Command {
    constructor() {
        var _a;
        super(...arguments);
        this.appendPlatformToFilename = false;
        this.isRelease = false;
        this.targetTripleDir = (_a = process.env.RUST_TARGET) !== null && _a !== void 0 ? _a : '';
        this.cargoFlags = '';
        this.target = '.';
    }
    execute() {
        var _a, _b, _c, _d;
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const cwd = this.cargoCwd
                ? path_1.join(process.cwd(), this.cargoCwd)
                : process.cwd();
            const releaseFlag = this.isRelease ? `--release` : '';
            const targetFLag = this.targetTripleDir
                ? `--target ${this.targetTripleDir}`
                : '';
            const featuresFlag = this.features ? `--features ${this.features}` : '';
            const triple = this.targetTripleDir
                ? parse_triple_1.parseTriple(this.targetTripleDir)
                : parse_triple_1.getDefaultTargetTriple(child_process_1.execSync('rustup show active-toolchain', {
                    env: process.env,
                }).toString('utf8'));
            debug(`Current triple is: ${chalk_1.default.green(triple.raw)}`);
            const externalFlags = [
                releaseFlag,
                targetFLag,
                featuresFlag,
                this.cargoFlags,
            ]
                .filter((flag) => Boolean(flag))
                .join(' ');
            const cargoCommand = `cargo build ${externalFlags}`;
            debug(`Run ${chalk_1.default.green(cargoCommand)}`);
            child_process_1.execSync(cargoCommand, {
                env: process.env,
                stdio: 'inherit',
                cwd,
            });
            const { binaryName } = consts_1.getNapiConfig(this.configFileName);
            let dylibName = this.cargoName;
            if (!dylibName) {
                let tomlContentString;
                let tomlContent;
                try {
                    debug('Start read toml');
                    tomlContentString = yield utils_1.readFileAsync(path_1.join(cwd, 'Cargo.toml'), 'utf-8');
                }
                catch (_e) {
                    throw new TypeError(`Could not find Cargo.toml in ${cwd}`);
                }
                try {
                    debug('Start parse toml');
                    tomlContent = toml_1.default.parse(tomlContentString);
                }
                catch (_f) {
                    throw new TypeError('Could not parse the Cargo.toml');
                }
                if ((_a = tomlContent.package) === null || _a === void 0 ? void 0 : _a.name) {
                    dylibName = tomlContent.package.name.replace(/-/g, '_');
                }
                else {
                    throw new TypeError('No package.name field in Cargo.toml');
                }
                if (!((_d = (_c = (_b = tomlContent.lib) === null || _b === void 0 ? void 0 : _b['crate-type']) === null || _c === void 0 ? void 0 : _c.includes) === null || _d === void 0 ? void 0 : _d.call(_c, 'cdylib'))) {
                    throw new TypeError(`Missing ${chalk_1.default.green('create-type = ["cdylib"]')} in ${chalk_1.default.green('[lib]')}`);
                }
            }
            debug(`Dylib name: ${chalk_1.default.greenBright(dylibName)}`);
            const platform = triple.platform;
            let libExt;
            debug(`Platform: ${chalk_1.default.greenBright(platform)}`);
            // Platform based massaging for build commands
            switch (platform) {
                case 'darwin':
                    libExt = '.dylib';
                    dylibName = `lib${dylibName}`;
                    break;
                case 'win32':
                    libExt = '.dll';
                    break;
                case 'linux':
                case 'freebsd':
                case 'openbsd':
                case 'android':
                case 'sunos':
                    dylibName = `lib${dylibName}`;
                    libExt = '.so';
                    break;
                default:
                    throw new TypeError('Operating system not currently supported or recognized by the build script');
            }
            const targetDir = path_1.join(this.targetTripleDir, this.isRelease ? 'release' : 'debug');
            const platformName = this.appendPlatformToFilename
                ? `.${triple.platformArchABI}`
                : '';
            debug(`Platform name: ${platformName || chalk_1.default.green('[Empty]')}`);
            let distModulePath = this.target
                ? path_1.join(this.target, `${binaryName}${platformName}.node`)
                : path_1.join('target', targetDir, `${binaryName}${platformName}.node`);
            const parsedDist = path_1.parse(distModulePath);
            if (!parsedDist.ext) {
                distModulePath = `${distModulePath}${platformName}.node`;
            }
            const dir = yield findUp(cwd);
            if (!dir) {
                throw new TypeError('No target dir found');
            }
            const sourcePath = path_1.join(dir, 'target', targetDir, `${dylibName}${libExt}`);
            if (yield utils_1.existsAsync(distModulePath)) {
                debug(`remove old binary [${chalk_1.default.yellowBright(sourcePath)}]`);
                yield utils_1.unlinkAsync(distModulePath);
            }
            debug(`Write binary content to [${chalk_1.default.yellowBright(distModulePath)}]`);
            yield utils_1.copyFileAsync(sourcePath, distModulePath);
        });
    }
}
BuildCommand.usage = clipanion_1.Command.Usage({
    description: 'Build and copy native module into specified dir',
});
tslib_1.__decorate([
    clipanion_1.Command.Boolean(`--platform`),
    tslib_1.__metadata("design:type", Object)
], BuildCommand.prototype, "appendPlatformToFilename", void 0);
tslib_1.__decorate([
    clipanion_1.Command.Boolean(`--release`),
    tslib_1.__metadata("design:type", Object)
], BuildCommand.prototype, "isRelease", void 0);
tslib_1.__decorate([
    clipanion_1.Command.String('--config,-c'),
    tslib_1.__metadata("design:type", String)
], BuildCommand.prototype, "configFileName", void 0);
tslib_1.__decorate([
    clipanion_1.Command.String('--cargo-name'),
    tslib_1.__metadata("design:type", String)
], BuildCommand.prototype, "cargoName", void 0);
tslib_1.__decorate([
    clipanion_1.Command.String('--target'),
    tslib_1.__metadata("design:type", Object)
], BuildCommand.prototype, "targetTripleDir", void 0);
tslib_1.__decorate([
    clipanion_1.Command.String('--features'),
    tslib_1.__metadata("design:type", String)
], BuildCommand.prototype, "features", void 0);
tslib_1.__decorate([
    clipanion_1.Command.String('--cargo-flags'),
    tslib_1.__metadata("design:type", Object)
], BuildCommand.prototype, "cargoFlags", void 0);
tslib_1.__decorate([
    clipanion_1.Command.String('--cargo-cwd'),
    tslib_1.__metadata("design:type", String)
], BuildCommand.prototype, "cargoCwd", void 0);
tslib_1.__decorate([
    clipanion_1.Command.String({
        required: false,
    }),
    tslib_1.__metadata("design:type", Object)
], BuildCommand.prototype, "target", void 0);
tslib_1.__decorate([
    clipanion_1.Command.Path('build'),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", Promise)
], BuildCommand.prototype, "execute", null);
exports.BuildCommand = BuildCommand;
function findUp(dir = process.cwd()) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const dist = path_1.join(dir, 'target');
        if (yield utils_1.existsAsync(dist)) {
            return dir;
        }
        const dirs = dir.split(path_1.sep);
        if (dirs.length < 2) {
            return null;
        }
        dirs.pop();
        return findUp(dirs.join(path_1.sep));
    });
}
//# sourceMappingURL=build.js.map