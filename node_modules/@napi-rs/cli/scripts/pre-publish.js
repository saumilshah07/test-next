"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PrePublishCommand = void 0;
const tslib_1 = require("tslib");
const path_1 = require("path");
const rest_1 = require("@octokit/rest");
const chalk_1 = tslib_1.__importDefault(require("chalk"));
const clipanion_1 = require("clipanion");
const consts_1 = require("./consts");
const debug_1 = require("./debug");
const spawn_1 = require("./spawn");
const update_package_1 = require("./update-package");
const utils_1 = require("./utils");
const version_1 = require("./version");
const debug = debug_1.debugFactory('prepublish');
class PrePublishCommand extends clipanion_1.Command {
    constructor() {
        super(...arguments);
        this.prefix = 'npm';
        this.tagStyle = 'lerna';
        this.isDryRun = false;
        this.skipGHRelease = false;
    }
    execute() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { packageJsonPath, platforms, version, packageName, binaryName } = consts_1.getNapiConfig(this.configFileName);
            debug(`Update optionalDependencies in [${packageJsonPath}]`);
            if (!this.isDryRun) {
                yield version_1.VersionCommand.updatePackageJson(this.prefix, this.configFileName);
                yield update_package_1.updatePackageJson(packageJsonPath, {
                    optionalDependencies: platforms.reduce((acc, cur) => {
                        acc[`${packageName}-${cur.platformArchABI}`] = `^${version}`;
                        return acc;
                    }, {}),
                });
            }
            const { owner, repo, pkgInfo } = yield this.createGhRelease(packageName, version);
            for (const platformDetail of platforms) {
                const pkgDir = path_1.join(process.cwd(), this.prefix, `${platformDetail.platformArchABI}`);
                const filename = `${binaryName}.${platformDetail.platformArchABI}.node`;
                const dstPath = path_1.join(pkgDir, filename);
                if (!this.isDryRun) {
                    if (!(yield utils_1.existsAsync(dstPath))) {
                        console.warn(`[${chalk_1.default.yellowBright(dstPath)}] is not existed`);
                        continue;
                    }
                    yield spawn_1.spawn('npm publish', {
                        cwd: pkgDir,
                        env: process.env,
                    });
                    if (!this.skipGHRelease) {
                        debug(`Start upload [${chalk_1.default.greenBright(dstPath)}] to Github release, [${chalk_1.default.greenBright(pkgInfo.tag)}]`);
                        const putasset = require('putasset');
                        try {
                            const downloadUrl = yield putasset(process.env.GITHUB_TOKEN, {
                                owner,
                                repo,
                                tag: pkgInfo.tag,
                                filename: dstPath,
                            });
                            console.info(`${chalk_1.default.green(dstPath)} upload success`);
                            console.info(`Download url: ${chalk_1.default.blueBright(downloadUrl)}`);
                        }
                        catch (e) {
                            debug(`Param: ${JSON.stringify({ owner, repo, tag: pkgInfo.tag, filename: dstPath }, null, 2)}`);
                            console.error(e);
                        }
                    }
                }
            }
        });
    }
    createGhRelease(packageName, version) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (this.skipGHRelease) {
                return {
                    owner: null,
                    repo: null,
                    pkgInfo: { name: null, version: null, tag: null },
                };
            }
            const headCommit = (yield spawn_1.spawn('git log -1 --pretty=%B'))
                .toString('utf8')
                .trim();
            debug(`Github repository: ${process.env.GITHUB_REPOSITORY}`);
            const [owner, repo] = process.env.GITHUB_REPOSITORY.split('/');
            const octokit = new rest_1.Octokit({
                auth: process.env.GITHUB_TOKEN,
            });
            let pkgInfo;
            if (this.tagStyle === 'lerna') {
                const packagesToPublish = headCommit
                    .split('\n')
                    .map((line) => line.trim())
                    .filter((line, index) => line.length && index)
                    .map((line) => line.substr(2))
                    .map(this.parseTag);
                pkgInfo = packagesToPublish.find((pkgInfo) => pkgInfo.name === packageName);
                if (!pkgInfo) {
                    throw new TypeError(`No release commit found with ${packageName}, original commit info: ${headCommit}`);
                }
            }
            else {
                pkgInfo = {
                    tag: `v${version}`,
                    version,
                    name: packageName,
                };
            }
            if (!this.isDryRun) {
                try {
                    yield octokit.repos.createRelease({
                        owner,
                        repo,
                        tag_name: pkgInfo.tag,
                    });
                }
                catch (e) {
                    debug(`Params: ${JSON.stringify({ owner, repo, tag_name: pkgInfo.tag }, null, 2)}`);
                    console.error(e);
                }
            }
            return { owner, repo, pkgInfo };
        });
    }
    parseTag(tag) {
        const segments = tag.split('@');
        const version = segments.pop();
        const name = segments.join('@');
        return {
            name,
            version,
            tag,
        };
    }
}
PrePublishCommand.usage = clipanion_1.Command.Usage({
    description: 'Update package.json and copy addons into per platform packages',
});
tslib_1.__decorate([
    clipanion_1.Command.String(`-p,--prefix`),
    tslib_1.__metadata("design:type", Object)
], PrePublishCommand.prototype, "prefix", void 0);
tslib_1.__decorate([
    clipanion_1.Command.String('--tagstyle,-t'),
    tslib_1.__metadata("design:type", String)
], PrePublishCommand.prototype, "tagStyle", void 0);
tslib_1.__decorate([
    clipanion_1.Command.String('-c,--config'),
    tslib_1.__metadata("design:type", String)
], PrePublishCommand.prototype, "configFileName", void 0);
tslib_1.__decorate([
    clipanion_1.Command.Boolean('--dry-run'),
    tslib_1.__metadata("design:type", Object)
], PrePublishCommand.prototype, "isDryRun", void 0);
tslib_1.__decorate([
    clipanion_1.Command.Boolean('--skip-gh-release'),
    tslib_1.__metadata("design:type", Object)
], PrePublishCommand.prototype, "skipGHRelease", void 0);
tslib_1.__decorate([
    clipanion_1.Command.Path('prepublish'),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", Promise)
], PrePublishCommand.prototype, "execute", null);
exports.PrePublishCommand = PrePublishCommand;
//# sourceMappingURL=pre-publish.js.map