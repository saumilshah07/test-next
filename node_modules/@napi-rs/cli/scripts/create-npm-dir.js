"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CreateNpmDirCommand = void 0;
const tslib_1 = require("tslib");
const fs_1 = require("fs");
const path_1 = require("path");
const chalk_1 = tslib_1.__importDefault(require("chalk"));
const clipanion_1 = require("clipanion");
const lodash_1 = require("lodash");
const consts_1 = require("./consts");
const debug_1 = require("./debug");
const utils_1 = require("./utils");
const debug = debug_1.debugFactory('create-npm-dir');
class CreateNpmDirCommand extends clipanion_1.Command {
    constructor() {
        super(...arguments);
        this.config = 'package.json';
    }
    execute() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield CreateNpmDirCommand.create(this.config, path_1.join(process.cwd(), this.targetDir), process.cwd());
        });
    }
}
CreateNpmDirCommand.usage = clipanion_1.Command.Usage({
    description: 'Create npm packages dir for platforms',
});
CreateNpmDirCommand.create = (config, targetDirPath, cwd) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const pkgJsonDir = config;
    debug(`Read content from [${chalk_1.default.yellowBright(pkgJsonDir)}]`);
    const { platforms, packageName, version, binaryName, content } = consts_1.getNapiConfig(pkgJsonDir, cwd);
    for (const platformDetail of platforms) {
        const targetDir = path_1.join(targetDirPath, 'npm', `${platformDetail.platformArchABI}`);
        fs_1.mkdirSync(targetDir, {
            recursive: true,
        });
        const binaryFileName = `${binaryName}.${platformDetail.platformArchABI}.node`;
        const targetPackageJson = path_1.join(targetDir, 'package.json');
        debug(`Write file [${chalk_1.default.yellowBright(targetPackageJson)}]`);
        yield utils_1.writeFileAsync(targetPackageJson, JSON.stringify(Object.assign({ name: `${packageName}-${platformDetail.platformArchABI}`, version, os: [platformDetail.platform], cpu: [platformDetail.arch], main: binaryFileName, files: [binaryFileName] }, lodash_1.pick(content, 'description', 'keywords', 'author', 'homepage', 'license', 'engines', 'publishConfig', 'repository', 'bugs')), null, 2));
        const targetReadme = path_1.join(targetDir, 'README.md');
        debug(`Write target README.md [${chalk_1.default.yellowBright(targetReadme)}]`);
        yield utils_1.writeFileAsync(targetReadme, readme(packageName, platformDetail));
    }
});
tslib_1.__decorate([
    clipanion_1.Command.String('-t,--target'),
    tslib_1.__metadata("design:type", String)
], CreateNpmDirCommand.prototype, "targetDir", void 0);
tslib_1.__decorate([
    clipanion_1.Command.String('-c,--config'),
    tslib_1.__metadata("design:type", Object)
], CreateNpmDirCommand.prototype, "config", void 0);
tslib_1.__decorate([
    clipanion_1.Command.Path('create-npm-dir'),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", Promise)
], CreateNpmDirCommand.prototype, "execute", null);
exports.CreateNpmDirCommand = CreateNpmDirCommand;
function readme(packageName, platformDetail) {
    return `# \`${packageName}-${platformDetail.platformArchABI}\`

This is the **${platformDetail.raw}** binary for \`${packageName}\`
`;
}
//# sourceMappingURL=create-npm-dir.js.map