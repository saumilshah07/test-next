export declare const LibRs = "#![deny(clippy::all)]\n\n#[macro_use]\nextern crate napi_derive;\n\nuse std::convert::TryInto;\n\nuse napi::{CallContext, Env, JsNumber, JsObject, Result, Task};\n\nstruct AsyncTask(u32);\n\nimpl Task for AsyncTask {\n  type Output = u32;\n  type JsValue = JsNumber;\n\n  fn compute(&mut self) -> Result<Self::Output> {\n    use std::thread::sleep;\n    use std::time::Duration;\n    sleep(Duration::from_millis(self.0 as u64));\n    Ok(self.0 * 2)\n  }\n\n  fn resolve(self, env: Env, output: Self::Output) -> Result<Self::JsValue> {\n    env.create_uint32(output)\n  }\n}\n\n#[module_exports]\nfn init(mut exports: JsObject) -> Result<()> {\n  exports.create_named_method(\"sync\", sync_fn)?;\n\n  exports.create_named_method(\"sleep\", sleep)?;\n  Ok(())\n}\n\n#[js_function(1)]\nfn sync_fn(ctx: CallContext) -> Result<JsNumber> {\n  let argument: u32 = ctx.get::<JsNumber>(0)?.try_into()?;\n\n  ctx.env.create_uint32(argument + 100)\n}\n\n#[js_function(1)]\nfn sleep(ctx: CallContext) -> Result<JsObject> {\n  let argument: u32 = ctx.get::<JsNumber>(0)?.try_into()?;\n  let task = AsyncTask(argument);\n  let async_task = ctx.env.spawn(task)?;\n  Ok(async_task.promise_object())\n}\n";
