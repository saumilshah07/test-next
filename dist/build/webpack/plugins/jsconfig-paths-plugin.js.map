{"version":3,"sources":["../../../../build/webpack/plugins/jsconfig-paths-plugin.ts"],"sourcesContent":["/**\n * This webpack resolver is largely based on TypeScript's \"paths\" handling\n * The TypeScript license can be found here:\n * https://github.com/microsoft/TypeScript/blob/214df64e287804577afa1fea0184c18c40f7d1ca/LICENSE.txt\n */\nimport path from 'path'\nimport { webpack } from 'next/dist/compiled/webpack/webpack'\nimport { debug } from 'next/dist/compiled/debug'\n\nconst log = debug('next:jsconfig-paths-plugin')\n\nexport interface Pattern {\n  prefix: string\n  suffix: string\n}\n\nconst asterisk = 0x2a\n\nexport function hasZeroOrOneAsteriskCharacter(str: string): boolean {\n  let seenAsterisk = false\n  for (let i = 0; i < str.length; i++) {\n    if (str.charCodeAt(i) === asterisk) {\n      if (!seenAsterisk) {\n        seenAsterisk = true\n      } else {\n        // have already seen asterisk\n        return false\n      }\n    }\n  }\n  return true\n}\n\n/**\n * Determines whether a path starts with a relative path component (i.e. `.` or `..`).\n */\nexport function pathIsRelative(testPath: string): boolean {\n  return /^\\.\\.?($|[\\\\/])/.test(testPath)\n}\n\nexport function tryParsePattern(pattern: string): Pattern | undefined {\n  // This should be verified outside of here and a proper error thrown.\n  const indexOfStar = pattern.indexOf('*')\n  return indexOfStar === -1\n    ? undefined\n    : {\n        prefix: pattern.substr(0, indexOfStar),\n        suffix: pattern.substr(indexOfStar + 1),\n      }\n}\n\nfunction isPatternMatch({ prefix, suffix }: Pattern, candidate: string) {\n  return (\n    candidate.length >= prefix.length + suffix.length &&\n    candidate.startsWith(prefix) &&\n    candidate.endsWith(suffix)\n  )\n}\n\n/** Return the object corresponding to the best pattern to match `candidate`. */\nexport function findBestPatternMatch<T>(\n  values: readonly T[],\n  getPattern: (value: T) => Pattern,\n  candidate: string\n): T | undefined {\n  let matchedValue: T | undefined\n  // use length of prefix as betterness criteria\n  let longestMatchPrefixLength = -1\n\n  for (const v of values) {\n    const pattern = getPattern(v)\n    if (\n      isPatternMatch(pattern, candidate) &&\n      pattern.prefix.length > longestMatchPrefixLength\n    ) {\n      longestMatchPrefixLength = pattern.prefix.length\n      matchedValue = v\n    }\n  }\n\n  return matchedValue\n}\n\n/**\n * patternStrings contains both pattern strings (containing \"*\") and regular strings.\n * Return an exact match if possible, or a pattern match, or undefined.\n * (These are verified by verifyCompilerOptions to have 0 or 1 \"*\" characters.)\n */\nexport function matchPatternOrExact(\n  patternStrings: readonly string[],\n  candidate: string\n): string | Pattern | undefined {\n  const patterns: Pattern[] = []\n  for (const patternString of patternStrings) {\n    if (!hasZeroOrOneAsteriskCharacter(patternString)) continue\n    const pattern = tryParsePattern(patternString)\n    if (pattern) {\n      patterns.push(pattern)\n    } else if (patternString === candidate) {\n      // pattern was matched as is - no need to search further\n      return patternString\n    }\n  }\n\n  return findBestPatternMatch(patterns, (_) => _, candidate)\n}\n\n/**\n * Tests whether a value is string\n */\nexport function isString(text: unknown): text is string {\n  return typeof text === 'string'\n}\n\n/**\n * Given that candidate matches pattern, returns the text matching the '*'.\n * E.g.: matchedText(tryParsePattern(\"foo*baz\"), \"foobarbaz\") === \"bar\"\n */\nexport function matchedText(pattern: Pattern, candidate: string): string {\n  return candidate.substring(\n    pattern.prefix.length,\n    candidate.length - pattern.suffix.length\n  )\n}\n\nexport function patternText({ prefix, suffix }: Pattern): string {\n  return `${prefix}*${suffix}`\n}\n\nconst NODE_MODULES_REGEX = /node_modules/\n\ntype Paths = { [match: string]: string[] }\n\n/**\n * Handles tsconfig.json or jsconfig.js \"paths\" option for webpack\n * Largely based on how the TypeScript compiler handles it:\n * https://github.com/microsoft/TypeScript/blob/1a9c8197fffe3dace5f8dca6633d450a88cba66d/src/compiler/moduleNameResolver.ts#L1362\n */\nexport class JsConfigPathsPlugin implements webpack.ResolvePlugin {\n  paths: Paths\n  resolvedBaseUrl: string\n  constructor(paths: Paths, resolvedBaseUrl: string) {\n    this.paths = paths\n    this.resolvedBaseUrl = resolvedBaseUrl\n    log('tsconfig.json or jsconfig.json paths: %O', paths)\n    log('resolved baseUrl: %s', resolvedBaseUrl)\n  }\n  apply(resolver: any) {\n    const paths = this.paths\n    const pathsKeys = Object.keys(paths)\n\n    // If no aliases are added bail out\n    if (pathsKeys.length === 0) {\n      log('paths are empty, bailing out')\n      return\n    }\n\n    const baseDirectory = this.resolvedBaseUrl\n    const target = resolver.ensureHook('resolve')\n    resolver\n      .getHook('described-resolve')\n      .tapPromise(\n        'JsConfigPathsPlugin',\n        async (request: any, resolveContext: any) => {\n          const moduleName = request.request\n\n          // Exclude node_modules from paths support (speeds up resolving)\n          if (request.path.match(NODE_MODULES_REGEX)) {\n            log('skipping request as it is inside node_modules %s', moduleName)\n            return\n          }\n\n          if (\n            path.posix.isAbsolute(moduleName) ||\n            (process.platform === 'win32' && path.win32.isAbsolute(moduleName))\n          ) {\n            log('skipping request as it is an absolute path %s', moduleName)\n            return\n          }\n\n          if (pathIsRelative(moduleName)) {\n            log('skipping request as it is a relative path %s', moduleName)\n            return\n          }\n\n          // log('starting to resolve request %s', moduleName)\n\n          // If the module name does not match any of the patterns in `paths` we hand off resolving to webpack\n          const matchedPattern = matchPatternOrExact(pathsKeys, moduleName)\n          if (!matchedPattern) {\n            log('moduleName did not match any paths pattern %s', moduleName)\n            return\n          }\n\n          const matchedStar = isString(matchedPattern)\n            ? undefined\n            : matchedText(matchedPattern, moduleName)\n          const matchedPatternText = isString(matchedPattern)\n            ? matchedPattern\n            : patternText(matchedPattern)\n\n          let triedPaths = []\n\n          for (const subst of paths[matchedPatternText]) {\n            const curPath = matchedStar\n              ? subst.replace('*', matchedStar)\n              : subst\n\n            // Ensure .d.ts is not matched\n            if (curPath.endsWith('.d.ts')) {\n              continue\n            }\n\n            const candidate = path.join(baseDirectory, curPath)\n            const [err, result] = await new Promise((resolve) => {\n              const obj = Object.assign({}, request, {\n                request: candidate,\n              })\n              resolver.doResolve(\n                target,\n                obj,\n                `Aliased with tsconfig.json or jsconfig.json ${matchedPatternText} to ${candidate}`,\n                resolveContext,\n                (resolverErr: any, resolverResult: any | undefined) => {\n                  resolve([resolverErr, resolverResult])\n                }\n              )\n            })\n\n            // There's multiple paths values possible, so we first have to iterate them all first before throwing an error\n            if (err || result === undefined) {\n              triedPaths.push(candidate)\n              continue\n            }\n\n            return result\n          }\n        }\n      )\n  }\n}\n"],"names":["hasZeroOrOneAsteriskCharacter","pathIsRelative","tryParsePattern","findBestPatternMatch","matchPatternOrExact","isString","matchedText","patternText","log","asterisk","str","seenAsterisk","i","length","charCodeAt","testPath","test","pattern","indexOfStar","indexOf","undefined","prefix","substr","suffix","isPatternMatch","candidate","startsWith","endsWith","values","getPattern","matchedValue","longestMatchPrefixLength","v","patternStrings","patterns","patternString","push","_","text","substring","NODE_MODULES_REGEX","JsConfigPathsPlugin","paths","resolvedBaseUrl","apply","resolver","pathsKeys","Object","keys","baseDirectory","target","ensureHook","getHook","tapPromise","request","resolveContext","moduleName","path","match","posix","isAbsolute","process","platform","win32","matchedPattern","matchedStar","matchedPatternText","triedPaths","subst","curPath","replace","join","err","result","Promise","resolve","obj","assign","doResolve","resolverErr","resolverResult"],"mappings":"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"}