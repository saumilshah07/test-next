{"version":3,"sources":["../../../../../build/webpack/loaders/next-serverless-loader/api-handler.ts"],"sourcesContent":["import { parse as parseUrl } from 'url'\nimport { IncomingMessage, ServerResponse } from 'http'\nimport { apiResolver } from '../../../../server/api-utils'\nimport { getUtils, vercelHeader, ServerlessHandlerCtx } from './utils'\nimport { DecodeError } from '../../../../shared/lib/utils'\n\nexport function getApiHandler(ctx: ServerlessHandlerCtx) {\n  const { pageModule, encodedPreviewProps, pageIsDynamic } = ctx\n  const {\n    handleRewrites,\n    handleBasePath,\n    dynamicRouteMatcher,\n    normalizeDynamicRouteParams,\n  } = getUtils(ctx)\n\n  return async (req: IncomingMessage, res: ServerResponse) => {\n    try {\n      // We need to trust the dynamic route params from the proxy\n      // to ensure we are using the correct values\n      const trustQuery = req.headers[vercelHeader]\n      const parsedUrl = handleRewrites(req, parseUrl(req.url!, true))\n\n      if (parsedUrl.query.nextInternalLocale) {\n        delete parsedUrl.query.nextInternalLocale\n      }\n      handleBasePath(req, parsedUrl)\n\n      let params = {}\n\n      if (pageIsDynamic) {\n        const result = normalizeDynamicRouteParams(\n          trustQuery\n            ? parsedUrl.query\n            : (dynamicRouteMatcher!(parsedUrl.pathname) as Record<\n                string,\n                string | string[]\n              >)\n        )\n\n        params = result.params\n      }\n\n      await apiResolver(\n        req,\n        res,\n        Object.assign({}, parsedUrl.query, params),\n        await pageModule,\n        encodedPreviewProps,\n        true\n      )\n    } catch (err) {\n      console.error(err)\n\n      if (err instanceof DecodeError) {\n        res.statusCode = 400\n        res.end('Bad Request')\n      } else {\n        // Throw the error to crash the serverless function\n        throw err\n      }\n    }\n  }\n}\n"],"names":["getApiHandler","ctx","pageModule","encodedPreviewProps","pageIsDynamic","handleRewrites","handleBasePath","dynamicRouteMatcher","normalizeDynamicRouteParams","req","res","trustQuery","headers","parsedUrl","url","query","nextInternalLocale","params","result","pathname","Object","assign","err","console","error","statusCode","end"],"mappings":";;;;QAMgBA,aAAa,GAAbA,aAAa;AANK,GAAK,CAAL,IAAK;AAEX,GAA8B,CAA9B,SAA8B;AACG,GAAS,CAAT,MAAS;AAC1C,GAA8B,CAA9B,OAA8B;SAE1CA,aAAa,CAACC,GAAyB,EAAE,CAAC;IACxD,KAAK,CAAC,CAAC,CAACC,UAAU,GAAEC,mBAAmB,GAAEC,aAAa,EAAC,CAAC,GAAGH,GAAG;IAC9D,KAAK,CAAC,CAAC,CACLI,cAAc,GACdC,cAAc,GACdC,mBAAmB,GACnBC,2BAA2B,IAC7B,CAAC,OAV0D,MAAS,WAUvDP,GAAG;IAEhB,MAAM,QAAQQ,GAAoB,EAAEC,GAAmB,GAAK,CAAC;QAC3D,GAAG,CAAC,CAAC;YACH,EAA2D,AAA3D,yDAA2D;YAC3D,EAA4C,AAA5C,0CAA4C;YAC5C,KAAK,CAACC,UAAU,GAAGF,GAAG,CAACG,OAAO,CAhByB,MAAS;YAiBhE,KAAK,CAACC,SAAS,GAAGR,cAAc,CAACI,GAAG,MApBR,IAAK,QAoBcA,GAAG,CAACK,GAAG,EAAG,IAAI;YAE7D,EAAE,EAAED,SAAS,CAACE,KAAK,CAACC,kBAAkB,EAAE,CAAC;gBACvC,MAAM,CAACH,SAAS,CAACE,KAAK,CAACC,kBAAkB;YAC3C,CAAC;YACDV,cAAc,CAACG,GAAG,EAAEI,SAAS;YAE7B,GAAG,CAACI,MAAM,GAAG,CAAC;YAAA,CAAC;YAEf,EAAE,EAAEb,aAAa,EAAE,CAAC;gBAClB,KAAK,CAACc,MAAM,GAAGV,2BAA2B,CACxCG,UAAU,GACNE,SAAS,CAACE,KAAK,GACdR,mBAAmB,CAAEM,SAAS,CAACM,QAAQ;gBAM9CF,MAAM,GAAGC,MAAM,CAACD,MAAM;YACxB,CAAC;YAED,KAAK,KAxCiB,SAA8B,cAyClDR,GAAG,EACHC,GAAG,EACHU,MAAM,CAACC,MAAM,CAAC,CAAC;YAAA,CAAC,EAAER,SAAS,CAACE,KAAK,EAAEE,MAAM,GACzC,KAAK,CAACf,UAAU,EAChBC,mBAAmB,EACnB,IAAI;QAER,CAAC,CAAC,KAAK,EAAEmB,GAAG,EAAE,CAAC;YACbC,OAAO,CAACC,KAAK,CAACF,GAAG;YAEjB,EAAE,EAAEA,GAAG,YAjDe,OAA8B,cAiDpB,CAAC;gBAC/BZ,GAAG,CAACe,UAAU,GAAG,GAAG;gBACpBf,GAAG,CAACgB,GAAG,CAAC,CAAa;YACvB,CAAC,MAAM,CAAC;gBACN,EAAmD,AAAnD,iDAAmD;gBACnD,KAAK,CAACJ,GAAG;YACX,CAAC;QACH,CAAC;IACH,CAAC;AACH,CAAC"}